<!DOCTYPE html>
<html>
<head>
    <title>Wedding Escape: Sibling Dodge!</title>
    <style>
        body { text-align: center; font-family: 'Segoe UI', Arial, sans-serif; background: #fce4ec; overflow: hidden; margin: 0; padding: 20px; }
        canvas { background: #fff; border: 8px solid #f06292; border-radius: 20px; display: block; margin: 0 auto; cursor: none; box-shadow: 0 10px 30px rgba(0,0,0,0.1); }
        h1 { color: #880e4f; margin: 10px 0; }
        #status { color: #ad1457; font-weight: bold; margin-bottom: 10px; }
    </style>
</head>
<body>
    <h1>üíç Catch the Groom, Dodge the Siblings! üíç</h1>
    <div id="status">Loading Wedding Party...</div>
    <canvas id="gameCanvas" width="800" height="550"></canvas>

    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const statusDiv = document.getElementById("status");

        // --- IMAGE LOADING SYSTEM ---
        const images = {};
        const sources = {
            bride: 'bride.jpg',
            groom: 'groom.jpg',
            s1: 'sibling1.jpg',
            s2: 'sibling2.jpg',
            s3: 'sibling3.jpg',
            s4: 'sibling4.jpg'
        };

        let loadedCount = 0;
        const totalImages = Object.keys(sources).length;

        for (let key in sources) {
            images[key] = new Image();
            images[key].onload = () => {
                loadedCount++;
                if (loadedCount === totalImages) {
                    statusDiv.innerText = "All set! Move your mouse to play.";
                    startGame();
                }
            };
            images[key].onerror = () => {
                statusDiv.innerText = "Error loading " + sources[key] + ". Check filenames!";
            };
            images[key].src = sources[key];
        }

        // --- GAME VARIABLES ---
        let score = 0;
        let lives = 3;
        let gameOver = false;
        const bride = { x: 360, y: 450, r: 45 };
        const items = [];
        const siblingKeys = ['s1', 's2', 's3', 's4'];

        function drawCircularImage(img, x, y, radius, borderColor) {
            ctx.save();
            ctx.beginPath();
            ctx.arc(x + radius, y + radius, radius, 0, Math.PI * 2);
            ctx.closePath();
            ctx.clip();
            ctx.drawImage(img, x, y, radius * 2, radius * 2);
            ctx.restore();
            
            if (borderColor) {
                ctx.beginPath();
                ctx.arc(x + radius, y + radius, radius, 0, Math.PI * 2);
                ctx.strokeStyle = borderColor;
                ctx.lineWidth = 5;
                ctx.stroke();
            }
        }

        function update() {
            if (gameOver) return;

            // Spawn Logic
            if (Math.random() < 0.04) {
                const isGroom = Math.random() > 0.8; // 20% chance for Groom
                const randomSiblingKey = siblingKeys[Math.floor(Math.random() * siblingKeys.length)];
                
                items.push({
                    x: Math.random() * (canvas.width - 90),
                    y: -100,
                    r: 40,
                    speed: 3 + Math.random() * 3 + (score / 150),
                    type: isGroom ? "GOAL" : "DODGE",
                    img: isGroom ? images.groom : images[randomSiblingKey]
                });
            }

            // Movement and Collision
            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                item.y += item.speed;

                // Physics-based distance check
                const dx = (item.x + item.r) - (bride.x + bride.r);
                const dy = (item.y + item.r) - (bride.y + bride.r);
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < bride.r + item.r - 10) {
                    if (item.type === "GOAL") {
                        score += 10;
                    } else {
                        lives--;
                        if (lives <= 0) gameOver = true;
                    }
                    items.splice(i, 1);
                    continue;
                }

                if (item.y > canvas.height) items.splice(i, 1);
            }

            draw();
            requestAnimationFrame(update);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw Bride (Pink)
            drawCircularImage(images.bride, bride.x, bride.y, bride.r, "#f06292");

            // Draw Falling Items
            items.forEach(item => {
                const color = item.type === "DODGE" ? "#ff4444" : "#ffd700";
                drawCircularImage(item.img, item.x, item.y, item.r, color);
            });

            // Draw HUD
            ctx.fillStyle = "#880e4f";
            ctx.font = "bold 26px Arial";
            ctx.textAlign = "left";
            ctx.fillText("Score: " + score, 20, 45);
            ctx.textAlign = "right";
            ctx.fillText("Lives: " + "‚ù§Ô∏è".repeat(lives), canvas.width - 20, 45);

            if (gameOver) {
                ctx.fillStyle = "rgba(136, 14, 79, 0.95)";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = "white";
                ctx.textAlign = "center";
                ctx.font = "bold 50px Arial";
                ctx.fillText("CAUGHT!", canvas.width/2, 240);
                ctx.font = "24px Arial";
                ctx.fillText("Final Score: " + score, canvas.width/2, 290);
                ctx.fillText("Click anywhere to restart", canvas.width/2, 340);
            }
        }

        function startGame() {
            update();
        }

        canvas.addEventListener("mousemove", (e) => {
            const rect = canvas.getBoundingClientRect();
            let targetX = e.clientX - rect.left - bride.r;
            // Bound checking
            if (targetX < 0) targetX = 0;
            if (targetX > canvas.width - (bride.r * 2)) targetX = canvas.width - (bride.r * 2);
            bride.x = targetX;
        });

        canvas.addEventListener("click", () => {
            if (gameOver) {
                score = 0; lives = 3; items.length = 0; gameOver = false;
                update();
            }
        });
    </script>
</body>
</html>