<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Wedding Escape: Mobile Edition</title>
    <style>
        body { 
            text-align: center; 
            font-family: 'Segoe UI', Arial, sans-serif; 
            background: #fce4ec; 
            margin: 0; 
            padding: 0; 
            overflow: hidden; /* Prevents scrolling while playing */
            touch-action: none; /* Prevents "pull-to-refresh" */
        }
        #game-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        canvas { 
            background: #fff; 
            border: 4px solid #f06292; 
            border-radius: 15px; 
            display: block; 
            max-width: 95%;
            max-height: 80%;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
        }
        h1 { color: #880e4f; font-size: 1.2rem; margin: 5px 0; }
        #status { color: #ad1457; font-size: 0.8rem; margin-bottom: 5px; }
    </style>
</head>
<body>
    <div id="game-container">
        <h1>üíç Sibling Dodge üíç</h1>
        <div id="status">Loading...</div>
        <canvas id="gameCanvas"></canvas>
    </div>

    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const statusDiv = document.getElementById("status");

        // Set internal resolution for Portrait
        const V_WIDTH = 400;
        const V_HEIGHT = 600;
        canvas.width = V_WIDTH;
        canvas.height = V_HEIGHT;

        const images = {};
        const sources = {
            bride: 'bride.jpg', groom: 'groom.jpg',
            s1: 'sibling1.jpg', s2: 'sibling2.jpg', s3: 'sibling3.jpg', s4: 'sibling4.jpg'
        };

        let loadedCount = 0;
        const totalImages = Object.keys(sources).length;

        for (let key in sources) {
            images[key] = new Image();
            images[key].src = sources[key];
            images[key].onload = () => {
                loadedCount++;
                if (loadedCount === totalImages) {
                    statusDiv.innerText = "Drag to move the Bride!";
                    requestAnimationFrame(gameLoop);
                }
            };
            images[key].onerror = () => {
                console.log("Failed: " + sources[key]);
                loadedCount++;
                images[key] = null; 
                if (loadedCount === totalImages) requestAnimationFrame(gameLoop);
            };
        }

        let score = 0, lives = 3, gameOver = false, items = [];
        const bride = { x: 160, y: 500, r: 35 };
        const siblingKeys = ['s1', 's2', 's3', 's4'];

        function drawEntity(img, x, y, radius, color) {
            ctx.save();
            ctx.beginPath();
            ctx.arc(x + radius, y + radius, radius, 0, Math.PI * 2);
            ctx.clip();
            if (img) ctx.drawImage(img, x, y, radius * 2, radius * 2);
            else { ctx.fillStyle = color; ctx.fill(); }
            ctx.restore();
            ctx.strokeStyle = color;
            ctx.lineWidth = 4;
            ctx.stroke();
        }

        function gameLoop() {
            ctx.clearRect(0, 0, V_WIDTH, V_HEIGHT);
            if (!gameOver) {
                if (Math.random() < 0.04) {
                    const isGroom = Math.random() > 0.8;
                    const sk = siblingKeys[Math.floor(Math.random() * siblingKeys.length)];
                    items.push({
                        x: Math.random() * (V_WIDTH - 70), y: -80, r: 35,
                        speed: 3 + Math.random() * 3 + (score/100),
                        type: isGroom ? "GOAL" : "DODGE",
                        img: isGroom ? images.groom : images[sk]
                    });
                }
                for (let i = items.length - 1; i >= 0; i--) {
                    const it = items[i]; it.y += it.speed;
                    const dx = (it.x + it.r) - (bride.x + bride.r);
                    const dy = (it.y + it.r) - (bride.y + bride.r);
                    if (Math.sqrt(dx*dx + dy*dy) < (bride.r + it.r) - 8) {
                        if (it.type === "GOAL") score += 10;
                        else { lives--; if (lives <= 0) gameOver = true; }
                        items.splice(i, 1); continue;
                    }
                    if (it.y > V_HEIGHT) items.splice(i, 1);
                }
            }

            drawEntity(images.bride, bride.x, bride.y, bride.r, "#f06292");
            items.forEach(it => drawEntity(it.img, it.x, it.y, it.r, it.type === "DODGE" ? "#ff0000" : "#ffd700"));
            
            ctx.fillStyle = "#880e4f"; ctx.font = "bold 20px Arial"; ctx.textAlign = "left";
            ctx.fillText(`Pts: ${score}`, 15, 30); ctx.textAlign = "right";
            ctx.fillText(`Lives: ${"‚ù§Ô∏è".repeat(Math.max(0, lives))}`, V_WIDTH - 15, 30);

            if (gameOver) {
                ctx.fillStyle = "rgba(136, 14, 79, 0.9)"; ctx.fillRect(0,0,V_WIDTH,V_HEIGHT);
                ctx.fillStyle = "white"; ctx.textAlign = "center"; ctx.font = "bold 30px Arial";
                ctx.fillText("GAME OVER", V_WIDTH/2, V_HEIGHT/2 - 20);
                ctx.font = "18px Arial"; ctx.fillText("Tap to Restart", V_WIDTH/2, V_HEIGHT/2 + 30);
            }
            requestAnimationFrame(gameLoop);
        }

        // --- UNIFIED CONTROLS (MOUSE + TOUCH) ---
        function handleInput(clientX) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = V_WIDTH / rect.width; // Map screen pixels to game pixels
            let tx = (clientX - rect.left) * scaleX - bride.r;
            bride.x = Math.max(0, Math.min(tx, V_WIDTH - bride.r * 2));
        }

        canvas.addEventListener("mousemove", (e) => { if (!gameOver) handleInput(e.clientX); });
        canvas.addEventListener("touchmove", (e) => {
            if (!gameOver) {
                handleInput(e.touches[0].clientX);
                e.preventDefault(); 
            }
        }, { passive: false });

        const restartAction = () => { if (gameOver) { score = 0; lives = 3; items = []; gameOver = false; } };
        canvas.addEventListener("mousedown", restartAction);
        canvas.addEventListener("touchstart", (e) => {
            if (gameOver) restartAction();
            else handleInput(e.touches[0].clientX);
        });
    </script>
</body>
</html>